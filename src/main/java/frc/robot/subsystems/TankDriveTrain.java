// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkLowLevel;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkBase;

import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;

/**
 * A drivetrain based on differential drive kinematics.
 */
public class TankDriveTrain extends SubsystemBase {

    private static final int kLeftSparkCANId = 9;
    private static final int kLeftTalon1CANId = 4;
    private static final int kLeftTalon2CANId = 6;

    private static final int kRightSparkCANId = 8;
    private static final int kRightTalon1CANId = 5;
    private static final int kRightTalon2CANId = 7;

    private static TankDriveTrain instance = null;

    public static final double kPositionConversionFactor = 1.0 / 3000.0;
    public static final double kTrackWidth = 0.6;
    public static final CANSparkBase.IdleMode idleMode = CANSparkBase.IdleMode.kBrake;


    final private DifferentialDriveKinematics kinematics = new DifferentialDriveKinematics(0.6);
    final private DifferentialDriveOdometry odometry = new DifferentialDriveOdometry(Rotation2d.fromDegrees(0.0), 0.0,
            0.0);

    // The left motor group
    private CANSparkMax leftSpark;
    private WPI_TalonSRX leftTalon1;
    private WPI_TalonSRX leftTalon2;
    private MotorControllerGroup leftMotorGroup;

    // The right motor group
    private CANSparkMax rightSpark;
    private WPI_TalonSRX rightTalon1;
    private WPI_TalonSRX rightTalon2;
    private MotorControllerGroup rightMotorGroup;

    // The robot's drive controller
    private DifferentialDrive differentialDrive1;

    double m_distance = 0.0;
    double m_speed = 0.0;
    double m_speed_filtered = 0.0;

    private final RelativeEncoder leftEncoder;
    private final RelativeEncoder rightEncoder;

    NetworkTable drivetrain_table;

    /**
     * Get the instance of the drivetrain.
     * 
     * @return the instance of the drivetrain.
     */
    public static TankDriveTrain getInstance() {
        if (instance == null) {
            instance = new TankDriveTrain();
        }
        return instance;
    }

    /**
    * Create a new instance of the drivetrain.
    */
    private TankDriveTrain() {

        leftSpark = new CANSparkMax(kLeftSparkCANId, CANSparkLowLevel.MotorType.kBrushless);
        leftTalon1 = new WPI_TalonSRX(kLeftTalon1CANId);
        leftTalon2 = new WPI_TalonSRX(kLeftTalon2CANId);
        leftMotorGroup = new MotorControllerGroup(leftSpark, leftTalon1, leftTalon2);
        addChild("Left Motor Group", leftMotorGroup);

        rightSpark = new CANSparkMax(kRightSparkCANId, CANSparkLowLevel.MotorType.kBrushless);
        rightTalon1 = new WPI_TalonSRX(kRightTalon1CANId);
        rightTalon2 = new WPI_TalonSRX(kRightTalon2CANId);
        rightMotorGroup = new MotorControllerGroup(rightSpark, rightTalon1, rightTalon2);
        addChild("Right Motor Group", rightMotorGroup);

        differentialDrive1 = new DifferentialDrive(leftMotorGroup, rightMotorGroup);
        addChild("Differential Drive 1", differentialDrive1);

        differentialDrive1.setSafetyEnabled(true);
        differentialDrive1.setExpiration(0.1);
        differentialDrive1.setMaxOutput(1.0);

        // The left configuration
        leftSpark.setIdleMode(idleMode);
        leftSpark.setInverted(true);
        leftSpark.burnFlash();

        leftTalon1.set(ControlMode.PercentOutput, 0.0);
        leftTalon1.configOpenloopRamp(0.2);
        leftTalon1.setInverted(false);

        leftTalon2.set(ControlMode.PercentOutput, 0.0);
        leftTalon2.configOpenloopRamp(0.2);
        leftTalon2.setInverted(false);

        // The right configuration
        rightSpark.setIdleMode(idleMode);
        rightSpark.setInverted(false);
        rightSpark.burnFlash();

        rightTalon1.set(ControlMode.PercentOutput, 0.0);
        rightTalon1.configOpenloopRamp(0.2);
        rightTalon1.setInverted(true);

        rightTalon2.set(ControlMode.PercentOutput, 0.0);
        rightTalon2.configOpenloopRamp(0.2);
        rightTalon2.setInverted(true);

        // Set the current limits
        SupplyCurrentLimitConfiguration current_limit = new SupplyCurrentLimitConfiguration();
        current_limit.currentLimit = 30;
        leftTalon1.configSupplyCurrentLimit(current_limit);
        leftTalon2.configSupplyCurrentLimit(current_limit);
        rightTalon1.configSupplyCurrentLimit(current_limit);
        rightTalon2.configSupplyCurrentLimit(current_limit);

        // Set up the encoders
        leftEncoder = leftSpark.getEncoder();
        rightEncoder = rightSpark.getEncoder();

        // set the encorder speed conversion factor from native units to meters per
        // second.
        leftEncoder.setVelocityConversionFactor(kPositionConversionFactor);
        rightEncoder.setVelocityConversionFactor(kPositionConversionFactor);

        // set the encorder position conversion factor from native units to meters.
        leftEncoder.setPositionConversionFactor(kPositionConversionFactor);
        rightEncoder.setPositionConversionFactor(kPositionConversionFactor);

        // TODO: Switch network tables to Comms3140
        NetworkTableInstance inst = NetworkTableInstance.getDefault();

        drivetrain_table = inst.getTable("SmartDashboard").getSubTable("DriveTrain");
    }

    /**
     * This method will be called once per scheduler run
     */
    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        m_distance = leftEncoder.getPosition();
        m_speed = leftEncoder.getVelocity();

        odometry.update(Rotation2d.fromDegrees(0.0), leftEncoder.getPosition(), rightEncoder.getPosition());

        drivetrain_table.getEntry("distance").setDouble(m_distance);
        drivetrain_table.getEntry("speed").setDouble(m_speed);
    }


    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    public void arcadeDrive(double xSpeed, double zRotation) {
        drivetrain_table.getEntry("arcade_xspeed").setNumber(xSpeed);
        drivetrain_table.getEntry("arcade_zrotation").setNumber(zRotation);

        differentialDrive1.arcadeDrive(xSpeed, zRotation);
    }

    public void curveDrive(double xSpeed,double zRotation){
        differentialDrive1.curvatureDrive(xSpeed , zRotation, false);
    }

    public double getSpeedFiltered() {
        return m_speed_filtered;
    }

    public double getSpeed() {
        return m_speed;
    }

    public double getPosition() {
        return m_distance;
    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Reset the drive encoders to currently read a position of 0.
     */
    public void resetEncoders() {
        leftEncoder.setPosition(0.0);
        rightEncoder.setPosition(0.0);
    }

    /**
     * Get the current pose of the robot using odometry.
     */
    public Pose2d getPose() {
        return odometry.getPoseMeters();
    }

    /**
     * Reset the odometry to the specified pose.
     * 
     * @param pose
     */
    public void resetOdometry(Pose2d pose) {
        odometry.resetPosition(Rotation2d.fromDegrees(0.0), leftEncoder.getPosition(),
                rightEncoder.getPosition(), pose);
    }

    /**
     * Reset the odometry to zero.
     */
    public void resetOdometry() {
        resetOdometry(new Pose2d());
    }

}
